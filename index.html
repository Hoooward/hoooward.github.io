<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Hexo</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1855353313/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Hoooward" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/03/01/2017-03-01 dispatch_semaphore 的使用/" class="post-title-link">dispatch_semaphore 的使用</a></h2><div class="post-info">Mar 1, 2017</div><div class="post-content"></div><a href="/2017/03/01/2017-03-01 dispatch_semaphore 的使用/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/21/2017-02-21/" class="post-title-link">编写高质量的 Objective-C 代码 3. 接口</a></h2><div class="post-info">Feb 21, 2017</div><div class="post-content"></div><a href="/2017/02/21/2017-02-21/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/19/对象、消息、运行时 /" class="post-title-link">编写高质量的 Objective-C 代码 第一章 对象、消息、运行时</a></h2><div class="post-info">Feb 19, 2017</div><div class="post-content"><h4 id="1-理解属性这一概念"><a href="#1-理解属性这一概念" class="headerlink" title="1. 理解属性这一概念"></a>1. 理解属性这一概念</h4><p>使用 @property 语法来定义对象中所封装的数据。<br>通过 <code>assign strong weak copy unsafe_unretained</code>定义存储数据所需的正确语义。<br>开发 iOS 程序时应该使用 <code>nonatomic</code> 属性，因为 <code>atomic</code> 属性会严重影响性能。</p>
<h4 id="2-在对象内部尽量直接访问实例变量"><a href="#2-在对象内部尽量直接访问实例变量" class="headerlink" title="2. 在对象内部尽量直接访问实例变量"></a>2. 在对象内部尽量直接访问实例变量</h4><p>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写，以确保其声明的内存管理语意。<br>在初始化和 <code>dealloc</code> 方法中，总是应该直接通过实例变量来读取数据。<br>在使用惰性初始化时，需要通过属性来读取数据。</p>
<h4 id="3-理解-对象等同性-这一概念。"><a href="#3-理解-对象等同性-这一概念。" class="headerlink" title="3. 理解 对象等同性 这一概念。"></a>3. 理解 <code>对象等同性</code> 这一概念。</h4><p>如果想检测对象的等同性，可提供 <code>NSObjcet</code>协议中的 <code>isEqual</code> 和 <code>hash</code> 方法。<br>相同的对象一定拥有相同的哈希码，但是两个哈希码相同的对象却未必相同。<br>不要盲目选择逐个检查每条属性，而是应该依照具体需求来定制方案，比如可以使用唯一的 <code>identifier</code> 来对比检查两个对象是否相等。<br>编写 <code>hash</code> 方法时,应该使用计算速度快而且哈希码碰撞几率低的算法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person 类</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span>: <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 实现 isEqual 方法</span></div><div class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</div><div class="line">	<span class="comment">// 如果指针相等，则其均指向同一对象</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span> == object) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 判断两个对象所属类是否相同</span></div><div class="line">	<span class="keyword">if</span> ([<span class="keyword">self</span> <span class="keyword">class</span>] != [object <span class="keyword">class</span>]) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 可能存在父类与子类进行对比</span></div><div class="line">	EOCPerson *otherPerson = (EOCPerson *)object;</div><div class="line">	<span class="comment">// 检查每个属性是否相等。</span></div><div class="line">	<span class="keyword">if</span> (![_firstName isEqualToString: otherPerson.firstName]) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (![_lastName isEqualToString: otherPerson.lastName]) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (_age != otherPerson.age) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">	&#125; </div><div class="line">	</div><div class="line">	<span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这种写法如果将对象放入集合中就会产生性能问题。</span></div><div class="line"><span class="comment">// 因为集合类型需要检索哈希表，会用对象的哈希码做索引。</span></div><div class="line">- （<span class="built_in">NSUInteger</span>)hash &#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">1337</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这种写法需要额外负担创建字符串开销。如果将对象放入集合，需要先计算哈希码。</span></div><div class="line">- （<span class="built_in">NSUInteger</span>)hash &#123;</div><div class="line">	<span class="built_in">NSString</span> *stringToHash = [<span class="built_in">NSString</span> stringWithFormat: <span class="string">@"%@:%@:%i"</span>, _firstName, _lastName, _age];</div><div class="line">	<span class="keyword">return</span> [stringToHash hash];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 既能保持较高效率，也不会过于频繁的重复。</span></div><div class="line"><span class="comment">// 在编写 hash 方法时， 应该用当前的对象做做实验，以便在减少碰撞频度与降低运算复杂度之间取舍。</span></div><div class="line">- （<span class="built_in">NSUInteger</span>)hash &#123;</div><div class="line">	<span class="built_in">NSUInteger</span> firstNameHash = [_firstName hash];</div><div class="line">	<span class="built_in">NSUInteger</span> lastNameHash = [_lastName hash];</div><div class="line">	<span class="built_in">NSUinteger</span> ageHash = _age;</div><div class="line">	<span class="keyword">return</span> firstNameHash ^ lastNameHash ^ ageHash;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2017/02/19/对象、消息、运行时 /" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/18/熟悉 Objective-C /" class="post-title-link">编写高质量的 Objective-C 代码 第一章 熟悉 Objective-C</a></h2><div class="post-info">Feb 18, 2017</div><div class="post-content"><p>因为好久没写 OC 代码了，回头重看 《Effective Objective-C 编写高质量 iOS 与 OS X 代码的 52 个有效方法》，总结一些 OC 编码时的技巧。</p>
<h5 id="1-除非必要，否则不要引入头文件"><a href="#1-除非必要，否则不要引入头文件" class="headerlink" title="1. 除非必要，否则不要引入头文件"></a>1. 除非必要，否则不要引入头文件</h5><p>一般来说，应再某个类的头文件中使用向前声明来提及某个类，并在实现文件（.m）中引入那些类的头文件，以降低类之间的耦合。<br>当无法使用向前声明时，比如要声明某个类遵循某个协议。在这种情况下，尽量把<code>该类遵循某协议</code>的声明移入<code>class-continuation 分类</code>中。如果不行的话，就把某协议单独放在一个头文件中，然后将其引入。</p>
<h5 id="2-尽量使用字面量创建数组、字典、字符串、数值"><a href="#2-尽量使用字面量创建数组、字典、字符串、数值" class="headerlink" title="2. 尽量使用字面量创建数组、字典、字符串、数值"></a>2. 尽量使用字面量创建数组、字典、字符串、数值</h5><p>与常规方法相比更加简明。同时，如果值中有 nil，则会抛出异常，方便定位问题。而使用常规方法遇到 nil 会自动结束向集合添加数值。<br></div><a href="/2017/02/18/熟悉 Objective-C /" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/28/git总结/" class="post-title-link">Git 命令清单</a></h2><div class="post-info">Nov 28, 2016</div><div class="post-content"><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="http://7xrfzx.com1.z0.glb.clouddn.com/2016-11-28-bg2015120901.png" alt="bg2015120901"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Workspace：工作区</div><div class="line">Index / Stage：暂存区</div><div class="line">Repository：仓库区（或本地仓库）</div><div class="line">Remote：远程仓库</div></pre></td></tr></table></figure></div><a href="/2016/11/28/git总结/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/30/隐藏NavigationBar底部的实线/" class="post-title-link">在 iOS10 中隐藏 NavigationBar 底部的实线.</a></h2><div class="post-info">Oct 30, 2016</div><div class="post-content"><p>在自己实现的项目中需要隐藏掉 UINavigtionBar 底部的实线, 并在底部添加一个外观一样的 UIView, 用来实现为 NavigationBar “增高”的功能. 之前在 iOS9 中使用的方法失效了. Google 了一下找到的通用的办法.</p>
<p>我们将这个功能写在 <code>UINavigationController</code> 的 extension 中. 首先利用简单的递归找到底部那条实线.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UINavigationController</span> </span>&#123; </div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">navigationBarLine</span><span class="params">(view: UIView)</span></span> -&gt; <span class="type">UIView</span>? &#123;</div><div class="line">    </div><div class="line">        <span class="keyword">if</span> view.isKind(of: <span class="type">UIImageView</span>.classForCoder()) </div><div class="line">        &amp;&amp; view.bounds.size.height &lt;= <span class="number">1.0</span> &#123;</div><div class="line">            <span class="keyword">return</span> view</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> view <span class="keyword">in</span> view.subviews &#123;</div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> imageView = navigationBarLine(view: view) &#123;</div><div class="line">                <span class="keyword">return</span> imageView</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2016/10/30/隐藏NavigationBar底部的实线/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/28/实现 StarRatingView 控件/" class="post-title-link">实现 StarRatingView 控件</a></h2><div class="post-info">Oct 28, 2016</div><div class="post-content"><p>自已项目中需要使用一个类此为 iTunes 中音乐评星的功能. 在 gihub 中找了一些发现都太繁琐. 本着一切从简, 能自己动手就自己动手的原则, 就参照开源的实现自己写了一个.</p>
<p>先来看看图片中我们要实现的控件.<br><img src="http://7xrfzx.com1.z0.glb.clouddn.com/2016-11-12-1.01.45.png" alt="1.01.45"><br>这个 <code>StarRatingView</code> 有两种状态, 分别是可编辑和不可编辑的状态. UI结构是一个 baseView 中拥有 5 个 <code>UIImageView</code>, 根据用户手指的移动 <code>CGPoint</code>, 为相应的 <code>UIImageView</code> 填充高亮或普通的 star 图片.<br></div><a href="/2016/10/28/实现 StarRatingView 控件/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/20/刷新UITableView&amp;UICollectionView/" class="post-title-link">刷新 UITableView & UICollectionView</a></h2><div class="post-info">Oct 20, 2016</div><div class="post-content"><p>当 tableView 或 collectionView 的数据发生变化时，我们需要自己来处理控制器的刷新行为，比如<code>reloadData</code> <code>insertRowsAtIndexPatch</code> 等刷新方法。我们很可能会使用到枚举或<code>if else</code>进行逻辑判断。在阅读 Yep 代码的时候发现了一种利用 <code>extension</code> 的方法，可以让控制器中的代码更加简洁。</p>
<p>我们首先为 UITableView 创建一个 extension, 并创建一个 enum 用来表示 tableView 的所有刷新行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableView</span> </span>&#123;</div><div class="line">    </div><div class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">WayToUpdata</span> </span>&#123;</div><div class="line">  </div><div class="line">    <span class="keyword">case</span> <span class="keyword">none</span></div><div class="line">    <span class="keyword">case</span> reloadData</div><div class="line">    <span class="keyword">case</span> insert([<span class="type">IndexPath</span>])</div><div class="line">    <span class="keyword">case</span> reloadAtIndexPath([<span class="type">IndexPath</span>])</div><div class="line">        </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2016/10/20/刷新UITableView&amp;UICollectionView/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/11/ActionSheetView/" class="post-title-link">比 UIAlertController 更好的选择</a></h2><div class="post-info">Oct 11, 2016</div><div class="post-content"><p>在 iOS 开发中我们会经常使用到 <code>UIAlertController</code>, 但本身提供的 API 接口有限, 自定义外观会非常麻烦, 更别提在其中使用自定义的 View 了. 今天我们来封装一个 <code>ActionSheetView</code>, 用来代替系统提供的 <code>actionSheet</code> 类型. </p>
<p><img src="http://7xrfzx.com1.z0.glb.clouddn.com/2016-11-13-屏幕快照 2016-11-13 下午1.46.14.png" alt="屏幕快照 2016-11-13 下午1.46.14"></p>
<p>图中底部弹出的菜单就是我们要实现的 <code>ActionSheetView</code>, 它有的主体结构是由一个 <code>UITableView</code> 来实现, 我们可以为其定制非常多种类的 <code>UITableViewCell</code>, 并通过 Swift 中的枚举关联值的特性,让其外部使用变得非常简单. 比如下面这种拥有 switch 开关的 cell.<br></div><a href="/2016/10/11/ActionSheetView/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/10/去除String空格/" class="post-title-link">去除 String 中多余的字符</a></h2><div class="post-info">Oct 10, 2016</div><div class="post-content"><p>在进行 App 内部搜索或者筛选网络加载的 String 内容时, 需要对字符串进行过滤. 比如我们有一个 textField 让用户在此输入 nickName, 他或许会调皮的输入一堆空格. 这时候就需要我们对用户的输入进行检查, 符合标准才能通过. 下面我们为 String 类型增加一个 extension 完成这样的功能.</p>
<p>首先定义一个 enum, 用来表示不同的过滤规则.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TrimmingType</span> </span>&#123;</div><div class="line">        <span class="comment">///去除两端空格</span></div><div class="line">        <span class="keyword">case</span> whitespace</div><div class="line">        <span class="comment">///去除换行和两端空格 </span></div><div class="line">        <span class="keyword">case</span> whitespaceAndNewLine</div><div class="line">        <span class="comment">///去除所有空格</span></div><div class="line">        <span class="keyword">case</span> squashingWhiteSpace</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2016/10/10/去除String空格/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/21/在Xcode8中继续使用XVIM/" class="post-title-link">在 Xcode8 中继续使用 XVim</a></h2><div class="post-info">Aug 21, 2016</div><div class="post-content"><p>在学习 iOS 开发初期的时候从一些技术大牛的文章中了解到 Vim 这个神器, 却因为学习成本过高, 屡次尝试屡次放弃. 直到某一天在 YouTube 上搜索到了一个叫做 <a href="https://www.youtube.com/watch?v=_NUO4JEtkDw">Learning Vim in a Week</a> 的讲座, 短短的20分钟视频让我迅速上手了 Vim. 视频中不仅仅介绍了 Vim 的组合键的应用场景. 还提到了一个非常实用的技巧: 利用 <code>Karabiner</code> 这款映射键盘的软件配置按键重复触发的延迟, 来让 <code>hjkl</code> 这些控制光标的操作如闪电般迅速. 经过反复观看视频, 大概一周左右的磨合, 就可以做到 <code>break up with your mouse</code> 了.<br></div><a href="/2016/08/21/在Xcode8中继续使用XVIM/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/16/实现一个简单的HUD/" class="post-title-link">封装一个简单的 HUD 视图</a></h2><div class="post-info">Aug 16, 2016</div><div class="post-content"><p>开发中我们通常在 App 长时间加载某些数据的时候需要展示 HUD 视图，告知用户当前 App 的状态。Apple 为我们提供了 <code>UIAlertView</code> <code>UIActivityView</code> 方便我们在必要的时候提醒用户。 但通常它们提供的 API 无法让我们做针对性的自定义，今天我们来实现一个简单的自定义 HUD。</p>
<p>首先我们先看一下在 App 中的实际运行效果。</p>
<p>结构非常简单: 一个灰色半透明的 <code>UIView</code> 和一个 <code>UIAvtivityIndicatorView</code> .<br></div><a href="/2016/08/16/实现一个简单的HUD/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/07/08/使用 Swift 优雅的缓存 Cell 的行高与 subviews 的 frame/" class="post-title-link">在 Swift 中优雅的缓存 cell 的行高与 subviews 的 layout</a></h2><div class="post-info">Jul 8, 2016</div><div class="post-content"><p><code>UITableView</code> 与 <code>UICollectionView</code> 无疑是 iOS 开发中使用最多的视图控制器，它往往负责展示大量的数据. 伴随着用户的手指不断的滑动，系统会反复刷新UI, 加载所要展示的内容。而一旦数据体积增大，计算的逻辑复杂，就会造成过多的性能浪费。解决这类问题的方法有很多. 最近在 <code>Yep</code> 代码中看到的方法，在应用到自己项目的时候感觉非常不错, 所以有了以下的记录总结.</p>
<p>首先看一下 Demo 要实现的效果<br></div><a href="/2016/07/08/使用 Swift 优雅的缓存 Cell 的行高与 subviews 的 frame/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/07/08/如何在进行-Segue-跳转时避免直接使用字符串/" class="post-title-link">使用 Segue 跳转时避免直接使用字符串</a></h2><div class="post-info">Jul 8, 2016</div><div class="post-content"><p>Xcode 的代码提示是没有办法验证字符串 (如: “Tychooo”) 的输入正确的, 我们在使用 storyboard 创建 UI 时, 经常会使用到 segue 的 identifier 来进行 viewController 跳转. 对其进行封装, 可以很好的减少自己手残输入错误时 debug 的时间成本. 我们一起来看一下 WWDC 中的 Demo.</p>
<p>我们首先定义一个协议 <code>SegueHandlerType</code>, 之后凡是需要用的 segue 跳转的 viewController 都需要循序此协议. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SegueHandlerType</span> </span>&#123;</div><div class="line">    associatedtype <span class="type">SegueIdentifier</span>: <span class="type">RawRepresentable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2016/07/08/如何在进行-Segue-跳转时避免直接使用字符串/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/30/Hexo/" class="post-title-link">Hexo Support</a></h2><div class="post-info">May 30, 2016</div><div class="post-content"><h4 id="Hexo-的文档结构"><a href="#Hexo-的文档结构" class="headerlink" title="Hexo 的文档结构"></a>Hexo 的文档结构</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">├── .deploy       #需要部署的文件</div><div class="line">├── node_modules  #<span class="type">Hexo</span>插件</div><div class="line">├── <span class="keyword">public</span>        #生成的静态网页文件</div><div class="line">├── scaffolds     #模板</div><div class="line">├── source        #博客正文和其他源文件, <span class="number">404</span> favicon <span class="type">CNAME</span> 等都应该放在这里</div><div class="line">|   ├── _drafts   #草稿</div><div class="line">|   └── _posts    #文章</div><div class="line">├── themes        #主题</div><div class="line">├── _config.yml   #全局配置文件</div><div class="line">└── package.json</div></pre></td></tr></table></figure></div><a href="/2016/05/30/Hexo/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/20/runtime/" class="post-title-link">为 UIImageView 添加 UIActivityIndicatorView</a></h2><div class="post-info">May 20, 2016</div><div class="post-content"><p>在实现类似与微博或者微信的 <code>timeline</code> 功能时, 往往需要在 <code>UITableViewCell</code> 中利用 <code>UIImageView</code> 展示单张或多张图片, 这些图片的来源通常都是网络. 而一旦网络速度不稳定, cell 中的 imageView 异步加载图片的过程就会一直显示 backgroundColor. 用户对图片正在下载的情况全然不知. 而像 <code>SDWebImage</code> 和 <code>Kingfisher</code> 这样的第三方框架很好的解决了这种问题: 一方面可以显示一张 placeholderImage, 也可以显示一个 <code>UIActivityIndicatorView</code> 让用户感受到下载的进程. </p>
<p>而实现 activityIndicatorView 的方法又有很多种, 我第一个想到的就是自定义一个 <code>UIView</code>, 在里面添加一个 <code>UIImageView</code> 和 一个 <code>UIActivityIndicatorView</code>. 之后使用这个自定义的 view 就可以很好的完成任务. 而最近我在使用 <code>Kingfisher</code> 时, 发现它利用 分类 的功能结合 runtime 的特性, 直接为 <code>UIImageView</code> 添加一个 indicatorView 的实例变量. </p>
<p>通过 分类 -&gt; extension 不能添加新的实例变量,  但我们可以利用 runtime 的 Associated Objects 来弥补这一不足.<br></div><a href="/2016/05/20/runtime/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/17/Stack-View的开始/" class="post-title-link">Stack View 的开始</a></h2><div class="post-info">Mar 17, 2016</div><div class="post-content"><p>作为一名刚刚入门 iOS 开发的人来说，理解并熟练使用 Auto Layhout 非常重要。开始接触自动布局是非常困难和复杂的，布局一个视图通常需要添加非常多的约束<code>constraints</code>，尤其是在创建动态视图时，我们要不断的重复添加和删除约束以达到我们想要的效果。而使用 <code>Stack View</code> 可以很大程度上简化我们频繁调试约束的过程。</p>
<p>通常,我们在创建用户界面的时候很多视图是程<code>线性</code>排列的。以下面这个界面为例，界面中包括非常多的子视图<code>UILabel</code>，它们是垂直<code>vertically</code>线性排列的。</p>
<p><img src="http://7xrfzx.com1.z0.glb.clouddn.com/2016-03-17-Screen Shot 2016-03-17 at 3.06.19 PM.png" alt="示例"><br></div><a href="/2016/03/17/Stack-View的开始/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/16/CS193P-第五课笔记/" class="post-title-link">CS193P 第五课笔记</a></h2><div class="post-info">Mar 16, 2016</div><div class="post-content"><h5 id="类型转换-Objective-C-和-Swift"><a href="#类型转换-Objective-C-和-Swift" class="headerlink" title="类型转换 Objective-C 和 Swift"></a>类型转换 Objective-C 和 Swift</h5><p>在 iOS 开发使用 Swift 时， 经常会遇到需要调用<code>Objective-C</code> 类方法的情况，苹果已经将几乎所有的<code>Objective－C</code>的API都已经无缝的转接到了 Swift，同时一些特别的类型也做了桥接，桥接意味着可以随意进行转换。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">Let</span> aString = (aString <span class="keyword">as</span> <span class="type">NSString</span>).lenght </div><div class="line">(anArray <span class="keyword">as</span> <span class="type">NSArray</span>).componentsJoinedByString(<span class="type">NSString</span>)</div><div class="line"><span class="comment">/**</div><div class="line">* Array 桥接到了 NSArray。对应的是AnyObject的数组。*</div><div class="line">* Dictionary 桥接到了 NSDictionary 对应的是 [NSObject：AnyObject]</div><div class="line">* Int, Float Double, Bool  都桥接到了 NSNumber （反过来不适用）</div><div class="line">* 如果需要从 NSNumber 对象中获取某个类型需要用 doubleValue，intValue 等。</div><div class="line">*/</span></div></pre></td></tr></table></figure></p>
<p>利用这种<code>括弧 + as</code>的方法可以直接调用<code>Objective-C</code>的方法， 同时实现了自动的类型转换，比如上面的例子，<code>lenght</code>是<code>NSString</code>的方法， 我们可直接在一行代码中将<code>String</code> 转换成<code>NSString</code>并调用其方法。<br></div><a href="/2016/03/16/CS193P-第五课笔记/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/16/CS193P-第四课笔记/" class="post-title-link">CS193P 第四课笔记</a></h2><div class="post-info">Mar 16, 2016</div><div class="post-content"><p>笔记信息的来源大部分来自课程随堂的Keynote，以及一些我个人的看法，因为没有软件开发的基础，难免容易混淆一些基础概念，还请各位看官斧正。<br>这节课主要介绍了在 iOS 开发中经常使用的结构类型，呈现了一些 Swift 语言的一些基础特性，更详细的语法和特性，还是需要仔细阅读苹果官方的<code>The Swift Programming Language</code>来了解的。<br></div><a href="/2016/03/16/CS193P-第四课笔记/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/16/Octopress的初级使用/" class="post-title-link"> Octopress 常用命令</a></h2><div class="post-info">Mar 16, 2016</div><div class="post-content"><p>前两天无意间看到一个部署 Octopress 的教程, 今天终于抽出时间折腾了一下.<br>因为对 Git、Rudy 和 HTML 没啥了解，遇到很多问题，所以先把今后可能用到的语法总结一下。<br><a href="http://octopress.org/docs/">Octopress文档链接</a></p>
<h2 id="代码高亮的-Syntax"><a href="#代码高亮的-Syntax" class="headerlink" title="代码高亮的 Syntax"></a>代码高亮的 Syntax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[language] [title] [url] [link text]</div><div class="line">code snippet</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">var</span> startIndex:<span class="type">T</span></div><div class="line">    <span class="keyword">var</span> endIndex:<span class="type">T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2016/03/16/Octopress的初级使用/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/16/iOS-中-UIGestureRecognizer-手势的使用/" class="post-title-link">UIGestureRecognizer 手势的使用</a></h2><div class="post-info">Mar 16, 2016</div><div class="post-content"><p>在 iOS 中包括下列几种手势识别，方便我们自定义一些与用户交互的操作方式。</p>
<p>###1.UIPinchGestureRecognizer<br> 两个手势放大或缩小，<code>Pinch</code> 手势传递的是比例，不是坐标。<br> 当手势开始的时候，比例是 1</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scale: <span class="type">CGFloat</span> <span class="comment">// not read-only (can set) 当两个手指扩大一倍的时候，scale 为2，靠拢到一半的时候 scale 变成 0.5 </span></div><div class="line"><span class="keyword">var</span> velocity: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// scale factor per second</span></div></pre></td></tr></table></figure>
<p>###2.UIRotationGestureRecognizer<br>两个手指的手势，在一个圆周上转动。就像一个旋转的按钮。他会告诉你旋转了多少弧度<code>retation</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> retation: <span class="type">CGFloat</span> <span class="comment">// not read-only (can reset); in radians</span></div><div class="line"><span class="keyword">var</span> velocity: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// radians per second</span></div></pre></td></tr></table></figure></div><a href="/2016/03/16/iOS-中-UIGestureRecognizer-手势的使用/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>