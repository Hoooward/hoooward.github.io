<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 编写高质量的 Objective-C 代码 2. 对象、消息、运行时 · Hexo</title><meta name="description" content="编写高质量的 Objective-C 代码 2. 对象、消息、运行时 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1855353313/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Hoooward" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">编写高质量的 Objective-C 代码 2. 对象、消息、运行时</h1><div class="post-info">Feb 19, 2017</div><div class="post-content"><h4 id="1-理解属性这一概念"><a href="#1-理解属性这一概念" class="headerlink" title="1. 理解属性这一概念"></a>1. 理解属性这一概念</h4><p>使用 @property 语法来定义对象中所封装的数据。<br>通过 <code>assign strong weak copy unsafe_unretained</code>定义存储数据所需的正确语义。<br>开发 iOS 程序时应该使用 <code>nonatomic</code> 属性，因为 <code>atomic</code> 属性会严重影响性能。</p>
<h4 id="2-在对象内部尽量直接访问实例变量"><a href="#2-在对象内部尽量直接访问实例变量" class="headerlink" title="2. 在对象内部尽量直接访问实例变量"></a>2. 在对象内部尽量直接访问实例变量</h4><p>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写，以确保其声明的内存管理语意。<br>在初始化和 <code>dealloc</code> 方法中，总是应该直接通过实例变量来读取数据。<br>在使用惰性初始化时，需要通过属性来读取数据。</p>
<h4 id="3-理解-对象等同性-这一概念。"><a href="#3-理解-对象等同性-这一概念。" class="headerlink" title="3. 理解 对象等同性 这一概念。"></a>3. 理解 <code>对象等同性</code> 这一概念。</h4><p>如果想检测对象的等同性，可提供 <code>NSObjcet</code>协议中的 <code>isEqual</code> 和 <code>hash</code> 方法。<br>相同的对象一定拥有相同的哈希码，但是两个哈希码相同的对象却未必相同。<br>不要盲目选择逐个检查每条属性，而是应该依照具体需求来定制方案，比如可以使用唯一的 <code>identifier</code> 来对比检查两个对象是否相等。<br>编写 <code>hash</code> 方法时,应该使用计算速度快而且哈希码碰撞几率低的算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// Person 类</div><div class="line">@interface EOCPerson: NSObject</div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, assign) NSUInteger age;</div><div class="line">@end</div><div class="line"></div><div class="line">// 实现 isEqual 方法</div><div class="line">- (BOOL)isEqual:(id)object &#123;</div><div class="line">	// 如果指针相等，则其均指向同一对象</div><div class="line">	if (self == object) &#123;</div><div class="line">		return YES;</div><div class="line">	&#125;</div><div class="line">	// 判断两个对象所属类是否相同</div><div class="line">	if ([self class] != [object class]) &#123;</div><div class="line">		return NO;</div><div class="line">	&#125;</div><div class="line">	// 可能存在父类与子类进行对比</div><div class="line">	EOCPerson *otherPerson = (EOCPerson *)object;</div><div class="line">	// 检查每个属性是否相等。</div><div class="line">	if (![_firstName isEqualToString: otherPerson.firstName]) &#123;</div><div class="line">		return NO;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	if (![_lastName isEqualToString: otherPerson.lastName]) &#123;</div><div class="line">		return NO;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	if (_age != otherPerson.age) &#123;</div><div class="line">		return NO;</div><div class="line">	&#125; </div><div class="line">	</div><div class="line">	return YES;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">// 这种写法如果将对象放入集合中就会产生性能问题。</div><div class="line">// 因为集合类型需要检索哈希表，会用对象的哈希码做索引。</div><div class="line">- （NSUInteger)hash &#123;</div><div class="line">	return 1337;</div><div class="line">&#125;</div><div class="line">// 这种写法需要额外负担创建字符串开销。如果将对象放入集合，需要先计算哈希码。</div><div class="line">- （NSUInteger)hash &#123;</div><div class="line">	NSString *stringToHash = [NSString stringWithFormat: @&quot;%@:%@:%i&quot;, _firstName, _lastName, _age];</div><div class="line">	return [stringToHash hash];</div><div class="line">&#125;</div><div class="line">// 既能保持较高效率，也不会过于频繁的重复。</div><div class="line">// 在编写 hash 方法时， 应该用当前的对象做做实验，以便在减少碰撞频度与降低运算复杂度之间取舍。</div><div class="line">- （NSUInteger)hash &#123;</div><div class="line">	NSUInteger firstNameHash = [_firstName hash];</div><div class="line">	NSUInteger lastNameHash = [_lastName hash];</div><div class="line">	NSUinteger ageHash = _age;</div><div class="line">	return firstNameHash ^ lastNameHash ^ ageHash;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="3-以-类族模式-隐藏实现细节"><a href="#3-以-类族模式-隐藏实现细节" class="headerlink" title="3. 以 类族模式 隐藏实现细节"></a>3. 以 <code>类族模式</code> 隐藏实现细节</h4><p>用以隐藏 <code>抽象基类</code> 的实现细节。 比如 <code>UIButton</code> 类，若想创建按钮，需要调用下面这个类方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 该方法返回的对象都继承自同一个基类 UIButton</div><div class="line">+ (UIButton *)buttonWithType:(UIButtonType)type;</div></pre></td></tr></table></figure>
<p>举例演示如何创建类族，假设有一个处理员工的类，每个员工都有名字和薪水两个属性，犹豫每个员工的工作内容不同，项目经理在带领员工做项目时，无需关心每个人如何完成工作，仅需指示其开工即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCEmployeeType) &#123;</div><div class="line">	EOCEmployeeTypeDeveloper = 0;</div><div class="line">	EOCEmployeeTypeDesigner;</div><div class="line">	EOCEmployeeTypeFinance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义抽象基类</div><div class="line">@interface EOCEmployee : NSObject</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@property (nonatomic, assign) NSUInteger salary;</div><div class="line"></div><div class="line">// 创建员工对象</div><div class="line">+ (EOCEmployee *)employeeWithType:(EOCEmployeeType)type;</div><div class="line"></div><div class="line">- (void)doADayWork;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCEmployee</div><div class="line"></div><div class="line">+ (EOCEmployee *)employeeWithType:(EOCEmployeeType)type &#123;</div><div class="line">	</div><div class="line">	switch (type) &#123;</div><div class="line">		case EOCEmployeeTypeDeveloper:</div><div class="line">			return [EOCEmployeeDeveloper new];</div><div class="line">			break;</div><div class="line">			</div><div class="line">		case EOCEmployeeTypeDesigner:</div><div class="line">			return [EOCEmployeeTypeDesigner new];</div><div class="line">			break;</div><div class="line">				</div><div class="line">		case EOCEmployeeTypeFinance:</div><div class="line">			return [EOCEmployeeTypeFinance new];</div><div class="line">			break;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)doADaysWork &#123;</div><div class="line">	// 因为 OC 中没有方法指明某个基类是抽象的</div><div class="line">	// 可以选择在基类的方法中抛出异常，避免外界调用。</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// 定义子类</div><div class="line">@interface EOCEmployeeDeveloper : EOCEmployee</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCEmployeeDeveloper</div><div class="line"></div><div class="line">- (void)doADaysWord &#123;</div><div class="line">	[self writeCode];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果对象所属的类位于某个类族，那么在查询其类型时要格外当心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 看上去会返回 YES，但实际返回 NO</div><div class="line">// 因为 employee 并非 Employee 类的实例，而是其子类的实例。</div><div class="line">[employee isMemberOfClass: [EOCEmployee class]]</div></pre></td></tr></table></figure>
<p>正确判断对象所属类是否位于某个类族时，应该使用下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">id maybeAnArray = /* ... */;</div><div class="line">// 正确</div><div class="line">if ([maybeAnArray isKindOfClass:[NSArray class]]) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 错误</div><div class="line">if ([maybeAnArray class] == [NSArray class]) &#123;</div><div class="line">    /*</div><div class="line">    永远不会执行，因为 NSArray 是个类族</div><div class="line">    [maybeAnArray class] 所返回的类不是 NSArray 类本地</div><div class="line">    因为 NSArray 的初始化方法所返回的那个实例是隐藏在类族公共接口后面的某个内部类型。</div><div class="line">    */</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">#### 4. 在既有类中使用关联对象存放自定义数据</div><div class="line">可以通过关联对象机制将两个对象链接起来。</div><div class="line">定义关联对象时可指定内存管理语义，用以模仿定义属性时采用的拥有关系和非拥有关系。</div><div class="line">只有再其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的 bug。</div><div class="line"></div><div class="line">管理关联对象的方法：</div><div class="line"></div><div class="line">```oc</div><div class="line">// 以给定的键值和策略对某对象设置关联对象值。</div><div class="line">void objc_setAssociatedObject(id object, void*key, id value, objec_AssociationPolicy policy)</div><div class="line">//根据给定的键从某对象中获取响应关联对象的值</div><div class="line">id objc_getAssociatedObject(id object, void*key)</div><div class="line">//移除指定对象的全部关联对象</div><div class="line">void objc_removeAssociatedObjects(id object)</div></pre></td></tr></table></figure>
<p>关联对象时内存管理的语义表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">关联类型</th>
<th style="text-align:center">等效的 @Property 属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_ASSIGN</td>
<td style="text-align:center">assign</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td style="text-align:center">nonatomic, retain</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td style="text-align:center">nonatomic, copy</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_RETAIN</td>
<td style="text-align:center">retain</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_COPY</td>
<td style="text-align:center">copy</td>
</tr>
</tbody>
</table>
<p>举例演示应用场景，比如 UIAlertView 类, 当用户点击按钮关闭视图时需要用 delegate 来处理动作。但代码分作两部分，读起来有点乱。所以可以使用关联对象的特性整合代码。(举例，并不推荐直接应用).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">static void *EOCMyAlertViewKey = &quot;EOCMyAlertViewKey&quot;;</div><div class="line"></div><div class="line">- (void)askUserAQuestion &#123;</div><div class="line">	</div><div class="line">	UIAlertView *alert = [[UIAlertView alloc] initWithTitle: @&quot;Question&quot; message: @&quot;What do you want to do?&quot; delegate: self, cancelButtonTitle: @&quot;Cancel&quot; otherButtonTitles:@&quot;Continue&quot;, nil];</div><div class="line">	</div><div class="line">	void (^block)(NSInteger) = ^(NSInteger buttonIndex) &#123;</div><div class="line">		if (buttonIndex == 0) &#123;</div><div class="line">			[self doCancel];</div><div class="line">		&#125; else &#123;</div><div class="line">			[self doContinue];</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	objc_setAssociateObject(alert, EOCMyAlertViewKey, block, BJC_ASSOCIATION_COPY);</div><div class="line">	</div><div class="line">	[alert show];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// UIAlertView Delegate</div><div class="line">- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex: (NSInteger) buttonIndex &#123;</div><div class="line">	void (^block)(NSInteger) = objc_getAssociatedObject(alertView EOCMyAlertViewKey);</div><div class="line">	block(buttonIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-理解-objc-megSend-的作用"><a href="#5-理解-objc-megSend-的作用" class="headerlink" title="5. 理解 objc_megSend 的作用"></a>5. 理解 objc_megSend 的作用</h4><p>传递消息是 OC 中经常使用的功能，消息有 name 或 selector 可以接受参数，而且可以能还有返回值。<br>由于 Objective-C 是 C 的超集，所以要先理解 C 语言的函数调用方式， C 语言使用静态绑定，也就是说，在编译期就能决定运行时所应调用的函数，比如以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#import &lt;stdio.h&gt;</div><div class="line"></div><div class="line">void printHello() &#123;</div><div class="line">printf(&quot;Hello, world!\n&quot;);</div><div class="line">&#125;</div><div class="line">void printGoodbye() &#123;</div><div class="line">printf(&quot;Goodbye, world!\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void doTheThing(int type) &#123;</div><div class="line">    if (type == 0) &#123;</div><div class="line">        printHello();</div><div class="line">    &#125; else &#123;</div><div class="line">        printGoodbye();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器在编译代码的时候就已经知道程序中有 printHello 和 printGoodbye 这两个函数了,于是会直接生成调用这些函数的指令。而函数地址实际上是硬编码在指令之中的。但如果写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void doTheThing(int type) &#123;</div><div class="line">    void (*fnc)();</div><div class="line">    if (type == 0) &#123;</div><div class="line">        fnc = printHello;</div><div class="line">    &#125; else &#123;</div><div class="line">        fnc = printGoodbye;</div><div class="line">    &#125;</div><div class="line">    fnc();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时就得使用动态绑定了，所调用的函数直到运行时才能确定。OC 如果要向某个对象传递消息就会使用动态绑定的机制来决定需要调用的方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// someObject -&gt; 消息接受者</div><div class="line">// messageName -&gt; selector</div><div class="line">// parameter -&gt; 参数</div><div class="line">id returnValue = [someObject messageName:parameter];</div><div class="line"></div><div class="line">// 其背后的 C 语言函数叫做 objc_msgSend</div><div class="line">void objc_msgSend(id self, SEL cmd, ...)</div><div class="line"></div><div class="line">// 转换之后</div><div class="line">id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter);</div><div class="line"></div><div class="line">// 对于一些特殊情况，会调用不同的 msgSend 函数</div><div class="line">// 如果待发送的消息要返回结构体，那么由此函数处理，仅当 CPU 寄存器能够容纳下该消息返回类型时执行。</div><div class="line">objc_msgSend_stret</div><div class="line">// 如果消息返回类型为浮点数，那么由此函数处理，为了解决类似 X86 架构 CPU 中某些令人奇怪的状况。</div><div class="line">objc_msgSend_fpret</div><div class="line">// 如果给超类发送消息，比如 [super class] 由此函数处理</div><div class="line">// 需要了解 super 仅是编辑器的标识符，并不是超类的指针</div><div class="line">// 调用 [super class] 仍然是向当前类发送消息。</div><div class="line">objc_msgSendSuper</div></pre></td></tr></table></figure>
<p>消息由接受者、selector 及参数构成，给某个对象发送消息也就是相当于在该对象上调用方法。<br>发送给某对象的全部消息都要由动态消息派发系统来处理，该系统查找对应的方法，并执行相应的代码。<br>每个类都拥有一张表格，其中的指针都指向方法实现的函数，<br>而 <code>selector</code> 就是查表时使用的 <code>key</code>。<br><code>objc_msgSend</code> 等函数就是通过这张表格来寻找应该执行的方法并跳转至其实现。</p>
<h4 id="6-理解消息转发机制"><a href="#6-理解消息转发机制" class="headerlink" title="6. 理解消息转发机制"></a>6. 理解消息转发机制</h4><p>当对象在收到无法解读的消息时就会启动消息转发机制，我们可由此过程告诉对象应该如何处理未知消息。</p>
<p>若对象无法响应某个 selector，则进入消息转发流程。<br>通过 <code>runtime</code> 的动态方法解析功能，我们可以在需要用到某个方法时再将其加入到类中。<br>对象可以把其无法解读的某个消息转交给其他对象处理。</p>
<p>消息转发分为两个阶段：</p>
<ol>
<li>第一阶段：询问接受者，所属的类，看其是否动态添加了方法 -&gt; 动态方法解析。</li>
<li>第二阶段：如果第一阶段执行结束，接受者就无法再用动态新增方法的手段来响应未知 <code>selector</code> 了。首先会询问接受者看看有没有其他对象能够处理这条消息，如果有，转发给那个对象，消息转发结束。如果没有备选的消息接受者，则启动完整的消息转发机制，将消息有关的细节封装到 <code>NSInvocation</code> 中，再给接受者最后一次机会，设法解决当前还未处理的消息。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 1. 对象在无法解读消息后，首先调用其所属类的这个方法</div><div class="line"></div><div class="line">/* </div><div class="line"> * return 表示这个类是否能新增一个实例方法处理 SEL</div><div class="line"> * 参数 selector: 未知的 selector</div><div class="line">*/</div><div class="line">// 处理实例方法</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector</div><div class="line">// 处理类方法</div><div class="line">+ (BOOL)resloveClassMethod:(SEL)selector</div><div class="line"></div><div class="line">// 2. 当前接受者还有第二次机会来处理未知 selector</div><div class="line">//    询问对象能不能将消息转发给其他接受者处理</div><div class="line"></div><div class="line">/* </div><div class="line"> * 在对象内部，可能还有一系列其他对象，该对象可经由此方法将</div><div class="line"> * 能够处理某 selector 的相关内部对象返回。</div><div class="line"> * return: 如果可以找到备选的接受者，将其返回，否则返回 nil </div><div class="line"> * 参数 selector: 未知的 selector</div><div class="line">*/</div><div class="line">- (id)forwardingTargetForSelector:(SEL)selector</div><div class="line"></div><div class="line">// 3. 如果进入这一步，唯一能做的就是启动完整消息转发机制。</div><div class="line"></div><div class="line">/*</div><div class="line"> * 这个方法基本和第二步的实现方法等效，所以应该场景可能是：</div><div class="line">  在触发消息前，以某种方式改变消息内容，比如追加另外一个参数，等。</div><div class="line">*/</div><div class="line">- (void)forwardInvocation:(NSInvocation *)invocation</div></pre></td></tr></table></figure>
<p>消息转发全流程图：<br><img src="http://7xrfzx.com1.z0.glb.clouddn.com/2017-02-19-14874995796584.jpg" alt=""><br>接受者在每一步均有机会处理消息，步骤越往后，处理消息的代价就越大。如果在第一步处理最好，这样的话，<code>runtime</code> 就可以将此方法缓存起来，之后该实例再接受到同样的 Selector 就无需启动转发流程了。若想在第三步转发消息，不如提前到第二部，就省去了创建 NSInvocation 的系统开销。</p>
<p>我们来看完整的例子，说明消息转发机制的意义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">@interface EOCAutoDictionary : NSObject</div><div class="line">@property (nonatomic, copy) NSString *string;</div><div class="line">@property (nonatomic, strong) NSNumber *number;</div><div class="line">@property (nonatomic, strong) NSDate *date;</div><div class="line">@property (nonatomic, strong) id opaqueObject;</div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;EOCAutoDictionary.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@interface EOCAutoDictionary()</div><div class="line">@property (nonatomic, strong) NSMutableDictionary *backingStore;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCAutoDictionary</div><div class="line">// 禁止编译器生成实例变量及存取方法</div><div class="line">@dynamic string, number, date, opaqueObject;</div><div class="line"></div><div class="line">- (id) init &#123;</div><div class="line">    </div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        _backingStore = [NSMutableDictionary new];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 取方法函数</div><div class="line">id autoDictionaryGetter(id self, SEL _cmd) &#123;</div><div class="line">    </div><div class="line">    EOCAutoDictionary *typedSelf = (EOCAutoDictionary *)self;</div><div class="line">    NSMutableDictionary *backingStore = typedSelf.backingStore;</div><div class="line">    </div><div class="line">    NSString *key = NSStringFromSelector(_cmd);</div><div class="line">    </div><div class="line">    return [backingStore objectForKey:key];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 存方法函数</div><div class="line">void autoDictionarySetter(id self, SEL _cmd, id value) &#123;</div><div class="line">    </div><div class="line">    EOCAutoDictionary *typedSelf = (EOCAutoDictionary *)self;</div><div class="line">    NSMutableDictionary *backingStore = typedSelf.backingStore;</div><div class="line">    </div><div class="line">    NSString *selectorString = NSStringFromSelector(_cmd);</div><div class="line">    NSMutableString *key = [selectorString mutableCopy];</div><div class="line">    </div><div class="line">    // 删除最后的 &apos;:&apos;</div><div class="line">    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];</div><div class="line">    </div><div class="line">    // 删除 &apos;set&apos; 前缀</div><div class="line">    [key deleteCharactersInRange:NSMakeRange(0, 3)];</div><div class="line">    </div><div class="line">    // 第一位小写</div><div class="line">    NSString *lowercaseFirstChar = [[key substringToIndex:1] lowercaseString];</div><div class="line">    [key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];</div><div class="line">    </div><div class="line">    if (value) &#123;</div><div class="line">        [backingStore setObject:value forKey:key];</div><div class="line">    &#125; else &#123;</div><div class="line">        [backingStore removeObjectForKey:key];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">// 动态添加实例方法</div><div class="line">+(BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    </div><div class="line">    NSString *selectorString = NSStringFromSelector(sel);</div><div class="line">    </div><div class="line">    if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;</div><div class="line">        class_addMethod(self,</div><div class="line">                        sel,</div><div class="line">                        (IMP)autoDictionarySetter,</div><div class="line">                        &quot;v@:@&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        class_addMethod(self,</div><div class="line">                        sel,</div><div class="line">                        (IMP)autoDictionaryGetter,</div><div class="line">                        &quot;@@:&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">// 测试</div><div class="line">EOCAutoDictionary *dict = [EOCAutoDictionary new];</div><div class="line">dict.date = [NSDate dateWithTimeIntervalSinceNow:475372800];</div><div class="line">    </div><div class="line">NSLog(@&quot;dict.date = %@&quot;, dict.date);</div><div class="line">// output: dict.date = 2032-03-14 11:01:57 +0000</div></pre></td></tr></table></figure>
<p>其他属性的访问方法与 date 类似， 要想添加新属性，只需要用 <code>@property</code> 来定义，并将其声明为 <code>@dynamic</code> 即可。</p>
<h4 id="7-方法替换-（method-swizzling）"><a href="#7-方法替换-（method-swizzling）" class="headerlink" title="7. 方法替换 （method swizzling）"></a>7. 方法替换 （method swizzling）</h4><p>类的方法列表会把 selector 的名称映射到相关的方法实现上，使得动态消息派发系统据此找到应该调用的方法。这些方法均以函数指针的形式来表示，即 IMP， 其原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id (* IMP)(id, SEL, ...)</div></pre></td></tr></table></figure>
<p>在运行时，可以向类中新增或者替换 selector 所对应的方法实现。<br>使用另一份实现来代替原有的方法实现，开发者常使用此技术向原有实现中添加新功能。<br>一般来说，只有调试程序时才需要修改方法实现，不宜滥用。</p>
<p>以 <code>NSString</code> 为例，它可以响应 <code>lowercaseString</code>、<code>uppercaseString</code>、<code>capitalizedString</code> 等方法，映射表如下:</p>
<p><img src="http://7xrfzx.com1.z0.glb.clouddn.com/2017-02-19-14875030634285.jpg" alt=""></p>
<p>而我们说的方法替换就是利用几个 <code>runtime</code> 函数来操作这张表，比如改成这样子：<br><img src="http://7xrfzx.com1.z0.glb.clouddn.com/2017-02-19-14875031488005.jpg" alt=""></p>
<p>上图中新增了 <code>newSelector</code> 方法，并交换了 lowercaseString 与 uppercaseString 的实现指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 实现交换两个方法实现的函数</div><div class="line">void method_exchangeImplementations(Method m1, Method m2);</div><div class="line">// 获取方法实现的函数</div><div class="line">Method class_getInstanceMethod(Class aClass, SEL aSelector);</div><div class="line">// 实现上图中交换两个方法实现的代码</div><div class="line">Method originalMethod = class_getInstanceMethod([NSString class], </div><div class="line">@selector(lowercaseString));</div><div class="line"></div><div class="line">Method swappedMethod = class_getInstanceMethod([NSString class], </div><div class="line">@selector(uppercaseString));</div><div class="line"></div><div class="line">method_exchangeImplementations(originalMethod, swappedMethod);</div></pre></td></tr></table></figure>
<p>当然，实际应用中像这样直接交换两个方法实现意义不大。但是可以通过这个手段为即有方法实现添加新功能。下面的示例演示如果为 <code>NSString</code> 的 <code>lowercaseString</code> 方法添加 Debug 的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 为 NSString 添加分类</div><div class="line"></div><div class="line">@interface NSString (EOCMyAdditions)</div><div class="line">- (NSString *)eoc_myLowercaseString;</div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;NSString+EOCMyAdditions.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation NSString (EOCMyAdditions)</div><div class="line">// 交换方法</div><div class="line">+(void)load &#123;</div><div class="line">    Method originalMethod = class_getInstanceMethod([NSString class], </div><div class="line">    @selector(lowercaseString));</div><div class="line">    Method swappedMethod = class_getInstanceMethod([NSString class], </div><div class="line">    @selector(eoc_myLowercaseString));</div><div class="line">    </div><div class="line">    method_exchangeImplementations(originalMethod, swappedMethod);</div><div class="line">&#125;</div><div class="line">// 看上去会陷入递归调用死循环，但运行时方法会进行交换。</div><div class="line">- (NSString *)eoc_myLowercaseString &#123;</div><div class="line">    NSString *lowercase = [self eoc_myLowercaseString];</div><div class="line">    NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase);</div><div class="line">    return lowercase;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// 测试</div><div class="line">NSString *string = @&quot;This iS tHe StRiNg&quot;;</div><div class="line">NSString *lowercaseString = [string lowercaseString];</div><div class="line">// Output: This iS tHe StRiNg =&gt; this is the string</div></pre></td></tr></table></figure>
<h4 id="8-理解-类对象-的用意"><a href="#8-理解-类对象-的用意" class="headerlink" title="8. 理解 类对象 的用意"></a>8. 理解 类对象 的用意</h4><p>描述 Objective-C 对象所用的数据结构定义在 runtime 库中的头文件中，其中 id 类型定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_object &#123;</div><div class="line">    Class isa;</div><div class="line">&#125; *id;</div></pre></td></tr></table></figure>
<p>每个对象结构体的首个成员就是 Class 类的变量，叫做 “is a” 指针, 该变量定义了对象所属的类。比如下面代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;This is a string&quot;;</div></pre></td></tr></table></figure>
<p>其中的 “is a” 指针指向的就是 NSString， Class 对象的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div><div class="line">struct objc_class &#123;</div><div class="line">    Class isa;</div><div class="line">    Class super_class;</div><div class="line">    const char *name;</div><div class="line">    long version;</div><div class="line">    long info;</div><div class="line">    long instance_size;</div><div class="line">    struct objc_ivar_lit *ivars;</div><div class="line">    struct objc_method_list **methodLists;</div><div class="line">    struct objc_cache *cache;</div><div class="line">    struct objc_protocol_list *protocols;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此结构体存放类的<code>元数据</code>， 当然这个结构体的首个变量也是 isa 指针， 说明 Class 本身也是 Objective-C 对象。结构体中还有一个叫做 <code>super_class</code> 的变量，它定义了本类的超类。类对象所属的类型 (也就是 isa 指针指向的类型) 是另外一个类，叫做 <code>元类</code>，用来描述类对象本身所具备的元数据。类方法就定义在此处。假如有一个名为 <code>SomeClass</code> 的子类继承自 <code>NSObject</code>，其继承体系如下图：<br><img src="http://7xrfzx.com1.z0.glb.clouddn.com/2017-02-19-14875051992425.jpg" alt=""></p>
<p>super_class 指针确定了继承关系，而 isa 指针描述了实例所属的类。这是我们在查询类继承体系时的参照标准。</p>
<p>我们使用 <code>isMemberOfClass</code> 能够判断出对象是否为某个特定类的实例， 而 <code>isKindOfClass</code> 则能判断出对象是否为某类或者其派生类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary *dict = [NSMutableDictionary new];</div><div class="line">[dict isMemberOfClass: [NSDictionary class]]; // = NO</div><div class="line">[dict isMemberOfClass: [NSMutableDictionary class]] // = YES</div><div class="line">[dict isKindOfClass: [NSDictionary class]]; // = YES</div><div class="line">[dict isKindOfClass: [NSArray class]]; // = NO</div></pre></td></tr></table></figure>
<p>像这样的类型查询方法使用 isa 指针获取对象所属的类，然后通过 super_class 指针在继承体系中游走。比如要查询某个集合类型中元素的类型，通常得到的结果是 id，如果想知道具体类型，就需要使用上面方法。假如我们需要根据数据中存储的对象来生成字符串，就是下列的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (NSString *)commaSeparatedStringFromObjects: (NSArray *)array &#123;</div><div class="line">    NSMutableString *string = [NSMutableString new];</div><div class="line">    </div><div class="line">    for (id object in array) &#123;</div><div class="line">        if ([object isKindOfClass: [NSString class]]) &#123;</div><div class="line">            [string appendFormat:@&quot;%@,&quot;, object];</div><div class="line">        &#125; else if ([object isKindOfClass: [NSNumber class]]) &#123;</div><div class="line">            [string appendFormat:@&quot;%d,&quot; ,[object intValue]];   </div><div class="line">        &#125; else if ([object isKindOfClass: [NSData class]]) &#123;</div><div class="line">            NSString *base64Encoded = /* base64 encoded data */;</div><div class="line">            [string appendFormat:@&quot;%@,&quot;, base64Encoded];</div><div class="line">        &#125; else &#123;</div><div class="line">            // 不支持的类型</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return string;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个实例都有一个指向 Class 对象的指针(isa), 用来表示其类型，而这些 Class 对象则构成了类的继承体系。<br>如果对象类型无法在编译器决定，那么就应该使用类型信息查询方法来探知。<br>尽量使用类型信息查询方法来确定对象类型，不要直接用 == 比较类对象，因为某些对象可能实现了消息转发。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2017/02/18/熟悉 Objective-C /" class="next">NEXT</a></div><div data-thread-key="2017/02/19/对象、消息、运行时 /" data-title="编写高质量的 Objective-C 代码 2. 对象、消息、运行时" data-url="http://yoursite.com/2017/02/19/对象、消息、运行时 /" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"seansun"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>