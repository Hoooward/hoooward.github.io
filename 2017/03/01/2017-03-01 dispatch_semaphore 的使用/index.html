<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> dispatch_semaphore 的使用 · Hexo</title><meta name="description" content="dispatch_semaphore 的使用 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1855353313/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Hoooward" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">dispatch_semaphore 的使用</h1><div class="post-info">Mar 1, 2017</div><div class="post-content"><p>利用 GCD 提供的 <code>dispatch_async</code> 方法在并发队列中执行任务时, 其任务的执行顺序以及并发数量不可控, 想要实现并发控制的解决方案其实有很多. 比如使用 <code>NSOperationQueue</code> 的 <code>maxConcurrentOperationCount</code> 属性可以控制 <code>NSOperation</code> 中同时执行任务的最大数量. 下面我们来看看再 GCD 中的解决方法</p>
<h4 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h4><p>我们先来看看有关 <code>dispatch_semaphore</code> 的三个方法.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_semaphore_create =&gt; 创建一个信号量       </div><div class="line">dispatch_semaphore_signal =&gt; 发送一个信号</div><div class="line">dispatch_semaphore_wait =&gt; 等待信号</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>我们可以像这样 <code>dispatch_semaphore_t semaphore = dispatch_semaphore_create(0)</code> 创建一个信号量, 方法需要传入一个 <code>long</code> 型的参数, 我们可以想象其为库存量.</p>
<p><code>dispatch_semaphore_wait</code> 很直观可以判断其是一个阻塞当前线程的方法, 其等待逻辑是每运行一次, 响应的库存就会减少一, 当库存量为 0 时, 这个方法就会根据传入的等待时间, 来决定等待添加库存的时间. 如果设置成 <code>DISPATCHTIMEFOREVER</code>, 那么就是永久等待添加库存, 否则就永远不往下执行.</p>
<p><code>dispatch_semaphore_signal</code> 就是添加库存的方法.</p>
<p>考虑下面的代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>); </div><div class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"等待 semaphore"</span>);</div></pre></td></tr></table></figure>
<p>上面代码中 <code>NSLog(@&quot;等待 semaphore&quot;);</code> 永远不会执行, 因为初始化的信号量库存是 0, 且等待库存增加的时间为 <code>DISPATCH_TIME_FOREVER</code>, 也就是说, 除非有地方执行 <code>dispatch_semaphore_signal</code> 增加库存, 否则就永远等待.</p>
<p>我们来看一个实际应用的场景:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ThreadSafeDictionary *dict = [[ThreadSafeDictionary alloc] init];</div><div class="line"></div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</div><div class="line">       </div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">     </div><div class="line">        [dict setObject:@(i) forKey:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d"</span>, i] block:^(ThreadSafeDictionary *dict, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> object) &#123;</div><div class="line">                </div><div class="line">        &#125;];</div><div class="line">            </div><div class="line">    &#125;</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">&#125;);</div><div class="line">    </div><div class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"----End dict = %@"</span>, dict);</div></pre></td></tr></table></figure>
<p>我们使用一个自定义线程安全的 Dictionary, 声明信号量库存为 0, 并执行一个 1000 次的写入数据的循环, 并选择在循环结束后,增加信号库存, 由于向字典写入数据的是异步在并发队列中的, 所以并不会阻塞当前线程, 会直接继续执行到<code>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</code>这行代码, 显而易见, 只有当 1000 次的写入数据结束, 库存量才会增加, 因此最后的 <code>NSLog</code> 会输出完整的字典.</p>
<p>当然我们也可以利用 <code>dispatch_semaphore_t</code> 控制并发数量. 下面是代码示例:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CustomOperationQueue</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithConcurrentCount:(<span class="keyword">int</span>)count &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (count &lt; <span class="number">1</span>) count = <span class="number">5</span>;</div><div class="line">        semaphore = dispatch_semaphore_create(count);</div><div class="line">        queue = Dispatch_queue_create(<span class="string">"com.custom.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">id</span>)init &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithConcurrentCount:<span class="number">5</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addTask:(TaskBlock)block &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        </div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">            <span class="keyword">if</span> (block) &#123;</div><div class="line">                block();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            dispatch_semaphore_signal(semaphore);</div><div class="line">                </div><div class="line">        &#125;);</div><div class="line">    </div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们把重点放在 <code>- (void)addTask:(TaskBlock)block</code> 方法中.<br>首先我们创建了一个库存量为 5 的信号量.<br>在方法内部因为库存为 5, 所以每添加一个任务 <code>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</code> 都会放行, 并减少一个库存, 而当我们完成一个任务, 也就是 <code>block()</code> 执行完毕后, 又会调用 <code>dispatch_semaphore_signal(semaphore)</code> 方法增加一个库存.<br>那么假如我们执行的任务耗时很长, 我们就会一直消耗库存, 如果添加到第 6 个任务时, 此时的库存数为 0,所以 <code>dispatch_semaphore_wait</code> 方法就会一直等待, 不执行第 6 个任务, 直到前面的某个任务完成,又增加了库存量, 才会放行执行第 6 个任务. 这样我们就实现了并发量的控制.</p>
<h4 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h4><p>检测并发任务是否全部执行完毕是 <code>dispatch_group</code> 常用的应用场景. 我们直接来看代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t serviceGroup = dispatch_group_create();<span class="comment">// 开始第一个请求     </span><span class="comment">// 进入组    </span>dispatch_group_enter(serviceGroup);[<span class="keyword">self</span>.configService startWithCompletion:^(ConfigResponse *results, <span class="built_in">NSError</span>* error)&#123;      configError = error;      <span class="comment">// 离开组</span>      dispatch_group_leave(serviceGroup);  &#125;];<span class="comment">// 开始第二个请求       </span><span class="comment">// 进入组</span>dispatch_group_enter(serviceGroup);[<span class="keyword">self</span>.preferenceService startWithCompletion:^(PreferenceResponse *results, <span class="built_in">NSError</span>* error)&#123;</div><div class="line">      <span class="comment">// 离开组    </span>      preferenceError = error; </div><div class="line">      dispatch_group_leave(serviceGroup);&#125;];<span class="comment">// 当组内任务清空后,通知主线程完成了所有的任务                          </span></div><div class="line">dispatch_group_notify(serviceGroup, dispatch_get_main_queue(),^&#123;    </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"两个请求都已经完成"</span>);  &#125;);</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2017/02/21/2017-02-21/" class="next">NEXT</a></div><div data-thread-key="2017/03/01/2017-03-01 dispatch_semaphore 的使用/" data-title="dispatch_semaphore 的使用" data-url="http://yoursite.com/2017/03/01/2017-03-01 dispatch_semaphore 的使用/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"seansun"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>